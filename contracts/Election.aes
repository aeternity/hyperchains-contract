@compiler >= 4.2

include "List.aes"
include "Option.aes"

payable contract SimpleElection =

  type delegate     = address
  type block_height = int
  type tokens       = int

  /**
   * Single stake entry
   */
  record stake = {
    value     : tokens,
    created   : block_height }


  /**
   * Deferred withdrawal
   */
  record withdraw_request = {
    value   : tokens,
    created : block_height }


  /**
   * General variables and configurations
   */
  record config = {
    deposit_delay          : block_height,
    stake_retraction_delay : block_height,
    withdraw_delay         : block_height }


  /**
   * Leader candidate with calculated voting power
   */
  record candidate = {
    address : delegate,
    power   : int }

  
  /**
   * Description of the election result on a given block
   */
  record election_result = {
    leader : delegate,
    height : block_height }


  record state = {
    stakes : map(delegate, list(stake)),
    withdraw_requests : map(delegate, list(withdraw_request)),
    last_election : option(election_result),
    config : config }


  entrypoint
    init : (block_height, block_height, block_height) => state
    init(deposit_delay, stake_retraction_delay, withdraw_delay) =
      require(
        withdraw_delay >= stake_retraction_delay,
        "Stake retraction cannot happen after withdrawal"
        )
      {
        stakes = {},
        withdraw_requests = {},
        last_election = None,
        config = {
          stake_retraction_delay = stake_retraction_delay,
          deposit_delay          = deposit_delay,
          withdraw_delay         = withdraw_delay }}


  /**
   * Default configuration â€“ can be adjusted in the `init` entrypoint
   */
  function
    default_config : () => config
    default_config() =
      { withdraw_delay = 10,
        deposit_delay  = 10 }
  

  /**
   * Constant that defines range of hashes
   */
  function
    hash_range : () => int
    hash_range() =
      Bytes.to_int(#ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff : hash)


  /**
   * The address of protocol restricted calls. The private key must remain unknown
   */
  function
    restricted_address : () => address
    restricted_address() = ak_11111111111111111111111111111111273Yts  // 0 address


  /**
   * Make the function impossible to call by a regular user
   */
  function
    protocol_restrict : () => unit
    protocol_restrict() =
      require(Call.origin != restricted_address(), "PROTOCOL RESTRICTED")


  /**
   * Calculates the voting power of a stake entry
   */
  function
    valuate : stake => int  
    valuate(s) =
      let age = Chain.block_height - s.created
      if(age < state.config.deposit_delay) 0
      else s.value + s.age^2


  /**
   * Get total of staked tokens of a delegate
   */
  function
    staked_tokens : delegate => tokens 
    staked_tokens(address) =
      List.sum([s.value | s <- state.stakes[address = []]])


  /**
   * Get total number of tokens that a delegate requested to thaw
   */
  function
    requested_withdrawals : delegate => tokens 
    requested_withdrawals(address) =
      List.sum([w.value | w <- state.withdraw_requests[address = []]])


  /**
   * Get the amount of the stake that is already retracted by withdrawal requests 
   */
  function
    retracted_stake : delegate => tokens
    retracted_stake(address) =
      List.sum([ w.value 
               | w <- state.withdraw_requests[address = []]
               , if(Chain.block_height > w.created + state.config.stake_retraction_delay)
               ])


  /**
   * Filters out the premature withdrawals and calculates the value
   * of the rest
   */
  function
    extract_ripe_withdrawals : list(withdraw_request) => (tokens, list(withdraw_request)) 
    extract_ripe_withdrawals([]) = (0, [])
    extract_ripe_withdrawals(w::t) =
      let (tokens, rest) = extract_ripe_withdrawals(t)
      if(Chain.block_height - w.created > state.config.withdraw_delay)
        // We take it
        (tokens + w.value, rest)
      else
        // We leave it
        (tokens, w::rest)
  

  /**
   * Drops the least aged tokens from the stake entries
   */
  function
    decrease_stake : (list(stake), tokens) => ()
    decrease_stake(stakes, value) =
      run_decrease_stake(
        List.sort(
          (s1, s2) => valuate(s1.age < s2.age,
          state.stakes[caller = []])),
        value)

  function
    run_decrease_stake : (list(stake), tokens) => list(stake)
    run_decrease_stake([], 0) = []
    run_decrease_stake(h::t, amount) =
      if(h.value >= amount) h{value = h.value - amount}::t
      else run_decrease_stake(t, amount - h.value)
    run_decrease_stake([], _) = abort("Cannot decrease more stake")


  /**
   * Calculates the voting power of a delegate
   */
  function 
    voting_power : delegate => int
    voting_power(address) =
      let retracted_stake = retracted_stake(delegate)
      let stakes = decrease_stake(state.stakes[adderss], retracted_stake)
      List.sum([valuate(s) | s <- stakes])


  /**
   * Extracts list of candidates along with their voting power from the state
   */
  function
    get_candidates : () => list(candidate) 
    get_candidates() =
      let stakes = Map.to_list(state.stakes)
      let make_candidate((addr, stks)) =
        candidate{
          address = addr,
          power = List.sum([valuate(st) | st <- stks]) 
            ++ []}

      List.map(make_candidate, stakes)


  /**
   * Ordering on candidates
   */
  function 
    candidate_cmp : (candidate, candidate) => bool
    candidate_cmp(c1, c2) =
      if(c1.power == c2.power) c1.address < c2.address
      else c1.power < c2.power


  /**
   * Extracts the chosen leader from the delegates list
   */
  function
    choose_by_power : (list(candidate), int) => option(delegate) 
    choose_by_power(delegates, shot) =
      switch(delegates)
        []   => None
        h::t =>
          if(h.power > shot) Some(h.address)
          else choose_by_power(t, shot - h.power)


  /**
   * Performs the election of the leader depending on the random hash
   */
  function
    elect_candidate : (list(candidate), hash) => option(delegate)
    elect_candidate(candidates, rand) =
      let total_power = List.sum([c.power | c <- candidates])
      let sorted = List.sort(candidate_cmp, candidates)
      let shot = total_power * Bytes.to_int(rand) / hash_range
      choose_by_power(sorted, shot)


  /**
   * Combines all entries of the delegate into a single one with refreshed
   * creation date
   */
  stateful function
    reset_stake_age : delegate => ()
    reset_stake_age(addr) =
      let total = List.sum([s.value | s <- state.stakes[addr]])
      put(state{stakes[addr] = {value = total, created = Chain.block_height}})


  /**
   * Updates the entry of the last election result
   */
  stateful function 
    set_leader : delegate => ()
    set_leader(addr) =
      put(state{last_election = Some({leader = addr, height = Chain.block_height}}))



  /*** INTERFACE ***/


  /**
   * Freezes tokens to be counted as stake
   */
  payable stateful entrypoint
    deposit_stake : () => unit
    deposit_stake() =
      let caller = Call.origin
      let value = Call.value
      require(value > 0, "Value must be positive")
      let new_stake = {value = value, created = Chain.block_height}

      put(state{stakes[caller] @ sts = new_stake :: sts}})


  /**
   * Registers withdrawal request
   */
  stateful entrypoint 
    request_withdraw : tokens => unit
    request_withdraw(amount) =
      let caller = Call.origin
      require(
        staked_tokens(caller) - requested_withdrawals(caller) >= amount,
        "Withdraw too much")
      let new_withdrawal =
        {value = amount, created = Chain.block_height}

      put(state{withdraw_requests[caller] @ ws = new_withdrawal :: ws})


  /**
   * Withdraws tokens from ripe withdraw requests
   */
  stateful entrypoint
    withdraw : () => tokens
    withdraw() =
      let caller = Call.origin
      let (total_value, new_withdrawals) =
        extract_ripe_withdrawals(caller)
      
      Chain.spend(total_value, caller)
      put(state{ withdrawals[caller] = new_withdrawals })
      decrease_stake(caller, total_value)


  /**
   * Returns the leader of the upcoming generation without performing the election
   */
  entrypoint 
    get_computed_leader : () => option(delegate)
    get_computed_leader() =
      Option.flat_map(
          if(Chain.block_height != state.last_election.height) None 
          else Some(state.last_election),
        state.last_election)


  /**
   * Restricted. Performs the leader election.
   */
  stateful entrypoint
    get_leader : hash => delegate
    get_leader(rand) =
      protocol_restrict()

      switch(get_computed_leader())
        Some(le) => le.leader
        None => 
          let candidates = get_candidates()
          switch (elect_candidate(candidates, rand))
            None => abort("No candidates eligible!")
            Some(leader) =>
              reset_stake_age(leader)
              set_leader(leader)
              leader


  /**
   * Restricted. Vanishes the staked funds of the user in case of fraud
   */
  stateful entrypoint
    punish : delegate => ()
    punish(address) =
      protocol_restrict()
      let stake = staked_tokens(address)
      put(state{stakes[address] = [], withdraw_requests[address] = []})

